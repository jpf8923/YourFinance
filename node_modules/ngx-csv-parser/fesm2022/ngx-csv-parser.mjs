import * as i0 from '@angular/core';
import { Injectable, Component, NgModule } from '@angular/core';
import { Observable } from 'rxjs';

class NgxCSVParserError {
}

class NgxCsvParser {
    constructor() {
        this.defaultCSVParserConfig = {
            header: true,
            delimiter: ',',
            encoding: 'utf8'
        };
    }
    parse(csvFile, config) {
        config = {
            ...this.defaultCSVParserConfig,
            ...config
        };
        const ngxCSVParserObserver = new Observable((observer) => {
            try {
                let csvRecords = null;
                if (this.isCSVFile(csvFile)) {
                    const reader = new FileReader();
                    reader.readAsText(csvFile, config.encoding);
                    reader.onload = () => {
                        const csvData = reader.result.trim();
                        if (csvData) {
                            const csvRecordsArray = this.csvStringToArray(csvData, config.delimiter);
                            const headersRow = this.getHeaderArray(csvRecordsArray);
                            csvRecords =
                                this.getDataRecordsArrayFromCSVFile(csvRecordsArray, headersRow.length, config);
                            observer.next(csvRecords);
                        }
                        else {
                            observer.next([]);
                        }
                        observer.complete();
                    };
                    reader.onerror = () => {
                        this.badCSVDataFormatErrorHandler(observer);
                    };
                }
                else {
                    this.notCSVFileErrorHandler(observer);
                }
            }
            catch (error) {
                this.unknownCSVParserErrorHandler(observer);
            }
        });
        return ngxCSVParserObserver;
    }
    csvStringToArray(csvDataString, delimiter) {
        const regexPattern = new RegExp(`(\\${delimiter}|\\r?\\n|\\r|^)(?:\"((?:\\\\.|\"\"|[^\\\\\"])*)\"|([^\\${delimiter}\"\\r\\n]*))`, 'gi');
        let matchedPatternArray = regexPattern.exec(csvDataString);
        const resultCSV = [[]];
        while (matchedPatternArray) {
            if (matchedPatternArray[1].length &&
                matchedPatternArray[1] !== delimiter) {
                resultCSV.push([]);
            }
            const cleanValue = matchedPatternArray[2]
                ? matchedPatternArray[2].replace(new RegExp('[\\\\"](.)', 'g'), '$1')
                : matchedPatternArray[3];
            resultCSV[resultCSV.length - 1].push(cleanValue);
            matchedPatternArray = regexPattern.exec(csvDataString);
        }
        return resultCSV;
    }
    getDataRecordsArrayFromCSVFile(csvRecordsArray, headerLength, config) {
        const dataArr = [];
        const headersArray = csvRecordsArray[0];
        const startingRowToParseData = config.header ? 1 : 0;
        for (let i = startingRowToParseData; i < csvRecordsArray.length; i++) {
            const data = csvRecordsArray[i];
            if (data.length === headerLength && config.header) {
                const csvRecord = {};
                for (let j = 0; j < data.length; j++) {
                    if (data[j] === undefined || data[j] === null) {
                        csvRecord[headersArray[j]] = '';
                    }
                    else {
                        csvRecord[headersArray[j]] = data[j].trim();
                    }
                }
                dataArr.push(csvRecord);
            }
            else {
                dataArr.push(data);
            }
        }
        return dataArr;
    }
    isCSVFile(file) {
        return file.name.toLowerCase().endsWith('.csv');
    }
    getHeaderArray(csvRecordsArr) {
        const headers = csvRecordsArr[0];
        const headerArray = [];
        for (const header of headers) {
            headerArray.push(header);
        }
        return headerArray;
    }
    notCSVFileErrorHandler(observer) {
        const ngcCSVParserError = this.errorBuilder('NOT_A_CSV_FILE', 'Selected file is not a csv File Type.', 2);
        observer.error(ngcCSVParserError);
    }
    unknownCSVParserErrorHandler(observer) {
        const ngcCSVParserError = this.errorBuilder('UNKNOWN_ERROR', 'Unknown error. Please refer to official documentation for library usage.', 404);
        observer.error(ngcCSVParserError);
    }
    badCSVDataFormatErrorHandler(observer) {
        const ngcCSVParserError = this.errorBuilder('BAD_CSV_DATA_FORMAT', 'Unable to parse CSV File.', 1);
        observer.error(ngcCSVParserError);
    }
    errorBuilder(type, message, code) {
        const ngcCSVParserError = new NgxCSVParserError();
        ngcCSVParserError.type = type;
        ngcCSVParserError.message = message;
        ngcCSVParserError.code = code;
        return ngcCSVParserError;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.0.3", ngImport: i0, type: NgxCsvParser, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.0.3", ngImport: i0, type: NgxCsvParser, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.0.3", ngImport: i0, type: NgxCsvParser, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }] });

class NgxCsvParserComponent {
    constructor() { }
    ngOnInit() {
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.0.3", ngImport: i0, type: NgxCsvParserComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.0.3", type: NgxCsvParserComponent, selector: "lib-ngx-csv-parser", ngImport: i0, template: `
    <p>
      ngx-csv-parser works!
    </p>
  `, isInline: true }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.0.3", ngImport: i0, type: NgxCsvParserComponent, decorators: [{
            type: Component,
            args: [{ selector: 'lib-ngx-csv-parser', template: `
    <p>
      ngx-csv-parser works!
    </p>
  ` }]
        }], ctorParameters: function () { return []; } });

class NgxCsvParserModule {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.0.3", ngImport: i0, type: NgxCsvParserModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "16.0.3", ngImport: i0, type: NgxCsvParserModule, declarations: [NgxCsvParserComponent], exports: [NgxCsvParserComponent] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "16.0.3", ngImport: i0, type: NgxCsvParserModule, providers: [NgxCsvParser] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.0.3", ngImport: i0, type: NgxCsvParserModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [NgxCsvParserComponent],
                    imports: [],
                    providers: [NgxCsvParser],
                    exports: [NgxCsvParserComponent]
                }]
        }] });

/*
 * Public API Surface of ngx-csv-parser
 */

/**
 * Generated bundle index. Do not edit.
 */

export { NgxCSVParserError, NgxCsvParser, NgxCsvParserComponent, NgxCsvParserModule };
//# sourceMappingURL=ngx-csv-parser.mjs.map
