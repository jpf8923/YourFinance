import { Injectable } from '@angular/core';
import { Observable } from 'rxjs';
import { NgxCSVParserError } from './_model/ngx-csv-parser-error.interface';
import * as i0 from "@angular/core";
export class NgxCsvParser {
    constructor() {
        this.defaultCSVParserConfig = {
            header: true,
            delimiter: ',',
            encoding: 'utf8'
        };
    }
    parse(csvFile, config) {
        config = {
            ...this.defaultCSVParserConfig,
            ...config
        };
        const ngxCSVParserObserver = new Observable((observer) => {
            try {
                let csvRecords = null;
                if (this.isCSVFile(csvFile)) {
                    const reader = new FileReader();
                    reader.readAsText(csvFile, config.encoding);
                    reader.onload = () => {
                        const csvData = reader.result.trim();
                        if (csvData) {
                            const csvRecordsArray = this.csvStringToArray(csvData, config.delimiter);
                            const headersRow = this.getHeaderArray(csvRecordsArray);
                            csvRecords =
                                this.getDataRecordsArrayFromCSVFile(csvRecordsArray, headersRow.length, config);
                            observer.next(csvRecords);
                        }
                        else {
                            observer.next([]);
                        }
                        observer.complete();
                    };
                    reader.onerror = () => {
                        this.badCSVDataFormatErrorHandler(observer);
                    };
                }
                else {
                    this.notCSVFileErrorHandler(observer);
                }
            }
            catch (error) {
                this.unknownCSVParserErrorHandler(observer);
            }
        });
        return ngxCSVParserObserver;
    }
    csvStringToArray(csvDataString, delimiter) {
        const regexPattern = new RegExp(`(\\${delimiter}|\\r?\\n|\\r|^)(?:\"((?:\\\\.|\"\"|[^\\\\\"])*)\"|([^\\${delimiter}\"\\r\\n]*))`, 'gi');
        let matchedPatternArray = regexPattern.exec(csvDataString);
        const resultCSV = [[]];
        while (matchedPatternArray) {
            if (matchedPatternArray[1].length &&
                matchedPatternArray[1] !== delimiter) {
                resultCSV.push([]);
            }
            const cleanValue = matchedPatternArray[2]
                ? matchedPatternArray[2].replace(new RegExp('[\\\\"](.)', 'g'), '$1')
                : matchedPatternArray[3];
            resultCSV[resultCSV.length - 1].push(cleanValue);
            matchedPatternArray = regexPattern.exec(csvDataString);
        }
        return resultCSV;
    }
    getDataRecordsArrayFromCSVFile(csvRecordsArray, headerLength, config) {
        const dataArr = [];
        const headersArray = csvRecordsArray[0];
        const startingRowToParseData = config.header ? 1 : 0;
        for (let i = startingRowToParseData; i < csvRecordsArray.length; i++) {
            const data = csvRecordsArray[i];
            if (data.length === headerLength && config.header) {
                const csvRecord = {};
                for (let j = 0; j < data.length; j++) {
                    if (data[j] === undefined || data[j] === null) {
                        csvRecord[headersArray[j]] = '';
                    }
                    else {
                        csvRecord[headersArray[j]] = data[j].trim();
                    }
                }
                dataArr.push(csvRecord);
            }
            else {
                dataArr.push(data);
            }
        }
        return dataArr;
    }
    isCSVFile(file) {
        return file.name.toLowerCase().endsWith('.csv');
    }
    getHeaderArray(csvRecordsArr) {
        const headers = csvRecordsArr[0];
        const headerArray = [];
        for (const header of headers) {
            headerArray.push(header);
        }
        return headerArray;
    }
    notCSVFileErrorHandler(observer) {
        const ngcCSVParserError = this.errorBuilder('NOT_A_CSV_FILE', 'Selected file is not a csv File Type.', 2);
        observer.error(ngcCSVParserError);
    }
    unknownCSVParserErrorHandler(observer) {
        const ngcCSVParserError = this.errorBuilder('UNKNOWN_ERROR', 'Unknown error. Please refer to official documentation for library usage.', 404);
        observer.error(ngcCSVParserError);
    }
    badCSVDataFormatErrorHandler(observer) {
        const ngcCSVParserError = this.errorBuilder('BAD_CSV_DATA_FORMAT', 'Unable to parse CSV File.', 1);
        observer.error(ngcCSVParserError);
    }
    errorBuilder(type, message, code) {
        const ngcCSVParserError = new NgxCSVParserError();
        ngcCSVParserError.type = type;
        ngcCSVParserError.message = message;
        ngcCSVParserError.code = code;
        return ngcCSVParserError;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.0.3", ngImport: i0, type: NgxCsvParser, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.0.3", ngImport: i0, type: NgxCsvParser, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.0.3", ngImport: i0, type: NgxCsvParser, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }] });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmd4LWNzdi1wYXJzZXIuc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3Byb2plY3RzL25neC1jc3YtcGFyc2VyL3NyYy9saWIvbmd4LWNzdi1wYXJzZXIuc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQzNDLE9BQU8sRUFBRSxVQUFVLEVBQVksTUFBTSxNQUFNLENBQUM7QUFDNUMsT0FBTyxFQUFFLGlCQUFpQixFQUFFLE1BQU0seUNBQXlDLENBQUM7O0FBTTVFLE1BQU0sT0FBTyxZQUFZO0lBSHpCO1FBSVksMkJBQXNCLEdBQW9CO1lBQzlDLE1BQU0sRUFBRSxJQUFJO1lBQ1osU0FBUyxFQUFFLEdBQUc7WUFDZCxRQUFRLEVBQUUsTUFBTTtTQUNuQixDQUFDO0tBb0tMO0lBbEtHLEtBQUssQ0FDRCxPQUFhLEVBQ2IsTUFBdUI7UUFFdkIsTUFBTSxHQUFHO1lBQ0wsR0FBRyxJQUFJLENBQUMsc0JBQXNCO1lBQzlCLEdBQUcsTUFBTTtTQUNaLENBQUM7UUFFRixNQUFNLG9CQUFvQixHQUFHLElBQUksVUFBVSxDQUN2QyxDQUFDLFFBQWtELEVBQUUsRUFBRTtZQUNuRCxJQUFJO2dCQUNBLElBQUksVUFBVSxHQUFHLElBQUksQ0FBQztnQkFFdEIsSUFBSSxJQUFJLENBQUMsU0FBUyxDQUFDLE9BQU8sQ0FBQyxFQUFFO29CQUN6QixNQUFNLE1BQU0sR0FBRyxJQUFJLFVBQVUsRUFBRSxDQUFDO29CQUNoQyxNQUFNLENBQUMsVUFBVSxDQUFDLE9BQU8sRUFBRSxNQUFNLENBQUMsUUFBUSxDQUFDLENBQUM7b0JBRTVDLE1BQU0sQ0FBQyxNQUFNLEdBQUcsR0FBRyxFQUFFO3dCQUNqQixNQUFNLE9BQU8sR0FBSSxNQUFNLENBQUMsTUFBaUIsQ0FBQyxJQUFJLEVBQUUsQ0FBQzt3QkFDakQsSUFBSSxPQUFPLEVBQUU7NEJBQ1QsTUFB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O1FBQ0YsUUFBUSxDQUFDLEtBQUssQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDO0lBQ3RDLENBQUM7SUFFRCw0QkFBNEIsQ0FBQyxRQUF1QjtRQUNoRCxNQUFNLGlCQUFpQixHQUFzQixJQUFJLENBQUMsWUFBWSxDQUMxRCxlQUFlLEVBQ2YsMEVBQTBFLEVBQzFFLEdBQUcsQ0FDTixDQUFDO1FBQ0YsUUFBUSxDQUFDLEtBQUssQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDO0lBQ3RDLENBQUM7SUFFRCw0QkFBNEIsQ0FBQyxRQUF1QjtRQUNoRCxNQUFNLGlCQUFpQixHQUFzQixJQUFJLENBQUMsWUFBWSxDQUMxRCxxQkFBcUIsRUFDckIsMkJBQTJCLEVBQzNCLENBQUMsQ0FDSixDQUFDO1FBQ0YsUUFBUSxDQUFDLEtBQUssQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDO0lBQ3RDLENBQUM7SUFFRCxZQUFZLENBQUMsSUFBWSxFQUFFLE9BQVksRUFBRSxJQUFTO1FBQzlDLE1BQU0saUJBQWlCLEdBQXNCLElBQUksaUJBQWlCLEVBQUUsQ0FBQztRQUNyRSxpQkFBaUIsQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDO1FBQzlCLGlCQUFpQixDQUFDLE9BQU8sR0FBRyxPQUFPLENBQUM7UUFDcEMsaUJBQWlCLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQztRQUM5QixPQUFPLGlCQUFpQixDQUFDO0lBQzdCLENBQUM7OEdBeEtRLFlBQVk7a0hBQVosWUFBWSxjQUZULE1BQU07OzJGQUVULFlBQVk7a0JBSHhCLFVBQVU7bUJBQUM7b0JBQ1IsVUFBVSxFQUFFLE1BQU07aUJBQ3JCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBPYnNlcnZhYmxlLCBPYnNlcnZlciB9IGZyb20gJ3J4anMnO1xyXG5pbXBvcnQgeyBOZ3hDU1ZQYXJzZXJFcnJvciB9IGZyb20gJy4vX21vZGVsL25neC1jc3YtcGFyc2VyLWVycm9yLmludGVyZmFjZSc7XHJcbmltcG9ydCB7IENTVlBhcnNlckNvbmZpZyB9IGZyb20gJy4vX21vZGVsL25neC1jc3YtcGFyc2VyLWNvbmZpZy5pbnRlcmZhY2UnO1xyXG5cclxuQEluamVjdGFibGUoe1xyXG4gICAgcHJvdmlkZWRJbjogJ3Jvb3QnXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBOZ3hDc3ZQYXJzZXIge1xyXG4gICAgcHJpdmF0ZSBkZWZhdWx0Q1NWUGFyc2VyQ29uZmlnOiBDU1ZQYXJzZXJDb25maWcgPSB7XHJcbiAgICAgICAgaGVhZGVyOiB0cnVlLFxyXG4gICAgICAgIGRlbGltaXRlcjogJywnLFxyXG4gICAgICAgIGVuY29kaW5nOiAndXRmOCdcclxuICAgIH07XHJcblxyXG4gICAgcGFyc2UoXHJcbiAgICAgICAgY3N2RmlsZTogRmlsZSxcclxuICAgICAgICBjb25maWc6IENTVlBhcnNlckNvbmZpZ1xyXG4gICAgKTogT2JzZXJ2YWJsZTxBcnJheTxhbnk+IHwgTmd4Q1NWUGFyc2VyRXJyb3I+IHtcclxuICAgICAgICBjb25maWcgPSB7XHJcbiAgICAgICAgICAgIC4uLnRoaXMuZGVmYXVsdENTVlBhcnNlckNvbmZpZyxcclxuICAgICAgICAgICAgLi4uY29uZmlnXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgY29uc3Qgbmd4Q1NWUGFyc2VyT2JzZXJ2ZXIgPSBuZXcgT2JzZXJ2YWJsZShcclxuICAgICAgICAgICAgKG9ic2VydmVyOiBPYnNlcnZlcjxBcnJheTxhbnk+IHwgTmd4Q1NWUGFyc2VyRXJyb3I+KSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBjc3ZSZWNvcmRzID0gbnVsbDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNDU1ZGaWxlKGNzdkZpbGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRlci5yZWFkQXNUZXh0KGNzdkZpbGUsIGNvbmZpZy5lbmNvZGluZyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZWFkZXIub25sb2FkID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY3N2RGF0YSA9IChyZWFkZXIucmVzdWx0IGFzIHN0cmluZykudHJpbSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNzdkRhdGEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjc3ZSZWNvcmRzQXJyYXkgPSB0aGlzLmNzdlN0cmluZ1RvQXJyYXkoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNzdkRhdGEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZy5kZWxpbWl0ZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBoZWFkZXJzUm93ID1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRIZWFkZXJBcnJheShjc3ZSZWNvcmRzQXJyYXkpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjc3ZSZWNvcmRzID1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXREYXRhUmVjb3Jkc0FycmF5RnJvbUNTVkZpbGUoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjc3ZSZWNvcmRzQXJyYXksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzUm93Lmxlbmd0aCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYnNlcnZlci5uZXh0KGNzdlJlY29yZHMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYnNlcnZlci5uZXh0KFtdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLmNvbXBsZXRlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZWFkZXIub25lcnJvciA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYmFkQ1NWRGF0YUZvcm1hdEVycm9ySGFuZGxlcihvYnNlcnZlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ub3RDU1ZGaWxlRXJyb3JIYW5kbGVyKG9ic2VydmVyKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudW5rbm93bkNTVlBhcnNlckVycm9ySGFuZGxlcihvYnNlcnZlcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICApO1xyXG5cclxuICAgICAgICByZXR1cm4gbmd4Q1NWUGFyc2VyT2JzZXJ2ZXI7XHJcbiAgICB9XHJcblxyXG4gICAgY3N2U3RyaW5nVG9BcnJheShjc3ZEYXRhU3RyaW5nOiBzdHJpbmcsIGRlbGltaXRlcjogc3RyaW5nKSB7XHJcbiAgICAgICAgY29uc3QgcmVnZXhQYXR0ZXJuID0gbmV3IFJlZ0V4cChcclxuICAgICAgICAgICAgYChcXFxcJHtkZWxpbWl0ZXJ9fFxcXFxyP1xcXFxufFxcXFxyfF4pKD86XFxcIigoPzpcXFxcXFxcXC58XFxcIlxcXCJ8W15cXFxcXFxcXFxcXCJdKSopXFxcInwoW15cXFxcJHtkZWxpbWl0ZXJ9XFxcIlxcXFxyXFxcXG5dKikpYCxcclxuICAgICAgICAgICAgJ2dpJ1xyXG4gICAgICAgICk7XHJcbiAgICAgICAgbGV0IG1hdGNoZWRQYXR0ZXJuQXJyYXkgPSByZWdleFBhdHRlcm4uZXhlYyhjc3ZEYXRhU3RyaW5nKTtcclxuICAgICAgICBjb25zdCByZXN1bHRDU1YgPSBbW11dO1xyXG4gICAgICAgIHdoaWxlIChtYXRjaGVkUGF0dGVybkFycmF5KSB7XHJcbiAgICAgICAgICAgIGlmIChcclxuICAgICAgICAgICAgICAgIG1hdGNoZWRQYXR0ZXJuQXJyYXlbMV0ubGVuZ3RoICYmXHJcbiAgICAgICAgICAgICAgICBtYXRjaGVkUGF0dGVybkFycmF5WzFdICE9PSBkZWxpbWl0ZXJcclxuICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHRDU1YucHVzaChbXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgY2xlYW5WYWx1ZSA9IG1hdGNoZWRQYXR0ZXJuQXJyYXlbMl1cclxuICAgICAgICAgICAgICAgID8gbWF0Y2hlZFBhdHRlcm5BcnJheVsyXS5yZXBsYWNlKFxyXG4gICAgICAgICAgICAgICAgICAgICAgbmV3IFJlZ0V4cCgnW1xcXFxcXFxcXCJdKC4pJywgJ2cnKSxcclxuICAgICAgICAgICAgICAgICAgICAgICckMSdcclxuICAgICAgICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICAgICAgOiBtYXRjaGVkUGF0dGVybkFycmF5WzNdO1xyXG4gICAgICAgICAgICByZXN1bHRDU1ZbcmVzdWx0Q1NWLmxlbmd0aCAtIDFdLnB1c2goY2xlYW5WYWx1ZSk7XHJcbiAgICAgICAgICAgIG1hdGNoZWRQYXR0ZXJuQXJyYXkgPSByZWdleFBhdHRlcm4uZXhlYyhjc3ZEYXRhU3RyaW5nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdENTVjtcclxuICAgIH1cclxuXHJcbiAgICBnZXREYXRhUmVjb3Jkc0FycmF5RnJvbUNTVkZpbGUoXHJcbiAgICAgICAgY3N2UmVjb3Jkc0FycmF5OiBhbnksXHJcbiAgICAgICAgaGVhZGVyTGVuZ3RoOiBhbnksXHJcbiAgICAgICAgY29uZmlnOiBhbnlcclxuICAgICkge1xyXG4gICAgICAgIGNvbnN0IGRhdGFBcnIgPSBbXTtcclxuICAgICAgICBjb25zdCBoZWFkZXJzQXJyYXkgPSBjc3ZSZWNvcmRzQXJyYXlbMF07XHJcblxyXG4gICAgICAgIGNvbnN0IHN0YXJ0aW5nUm93VG9QYXJzZURhdGEgPSBjb25maWcuaGVhZGVyID8gMSA6IDA7XHJcblxyXG4gICAgICAgIGZvciAobGV0IGkgPSBzdGFydGluZ1Jvd1RvUGFyc2VEYXRhOyBpIDwgY3N2UmVjb3Jkc0FycmF5Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBjc3ZSZWNvcmRzQXJyYXlbaV07XHJcblxyXG4gICAgICAgICAgICBpZiAoZGF0YS5sZW5ndGggPT09IGhlYWRlckxlbmd0aCAmJiBjb25maWcuaGVhZGVyKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjc3ZSZWNvcmQgPSB7fTtcclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGRhdGEubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YVtqXSA9PT0gdW5kZWZpbmVkIHx8IGRhdGFbal0gPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3N2UmVjb3JkW2hlYWRlcnNBcnJheVtqXV0gPSAnJztcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjc3ZSZWNvcmRbaGVhZGVyc0FycmF5W2pdXSA9IGRhdGFbal0udHJpbSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGRhdGFBcnIucHVzaChjc3ZSZWNvcmQpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZGF0YUFyci5wdXNoKGRhdGEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkYXRhQXJyO1xyXG4gICAgfVxyXG5cclxuICAgIGlzQ1NWRmlsZShmaWxlOiBhbnkpIHtcclxuICAgICAgICByZXR1cm4gZmlsZS5uYW1lLnRvTG93ZXJDYXNlKCkuZW5kc1dpdGgoJy5jc3YnKTtcclxuICAgIH1cclxuXHJcbiAgICBnZXRIZWFkZXJBcnJheShjc3ZSZWNvcmRzQXJyOiBhbnkpIHtcclxuICAgICAgICBjb25zdCBoZWFkZXJzID0gY3N2UmVjb3Jkc0FyclswXTtcclxuICAgICAgICBjb25zdCBoZWFkZXJBcnJheSA9IFtdO1xyXG4gICAgICAgIGZvciAoY29uc3QgaGVhZGVyIG9mIGhlYWRlcnMpIHtcclxuICAgICAgICAgICAgaGVhZGVyQXJyYXkucHVzaChoZWFkZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaGVhZGVyQXJyYXk7XHJcbiAgICB9XHJcblxyXG4gICAgbm90Q1NWRmlsZUVycm9ySGFuZGxlcihvYnNlcnZlcjogT2JzZXJ2ZXI8YW55Pikge1xyXG4gICAgICAgIGNvbnN0IG5nY0NTVlBhcnNlckVycm9yOiBOZ3hDU1ZQYXJzZXJFcnJvciA9IHRoaXMuZXJyb3JCdWlsZGVyKFxyXG4gICAgICAgICAgICAnTk9UX0FfQ1NWX0ZJTEUnLFxyXG4gICAgICAgICAgICAnU2VsZWN0ZWQgZmlsZSBpcyBub3QgYSBjc3YgRmlsZSBUeXBlLicsXHJcbiAgICAgICAgICAgIDJcclxuICAgICAgICApO1xyXG4gICAgICAgIG9ic2VydmVyLmVycm9yKG5nY0NTVlBhcnNlckVycm9yKTtcclxuICAgIH1cclxuXHJcbiAgICB1bmtub3duQ1NWUGFyc2VyRXJyb3JIYW5kbGVyKG9ic2VydmVyOiBPYnNlcnZlcjxhbnk+KSB7XHJcbiAgICAgICAgY29uc3QgbmdjQ1NWUGFyc2VyRXJyb3I6IE5neENTVlBhcnNlckVycm9yID0gdGhpcy5lcnJvckJ1aWxkZXIoXHJcbiAgICAgICAgICAgICdVTktOT1dOX0VSUk9SJyxcclxuICAgICAgICAgICAgJ1Vua25vd24gZXJyb3IuIFBsZWFzZSByZWZlciB0byBvZmZpY2lhbCBkb2N1bWVudGF0aW9uIGZvciBsaWJyYXJ5IHVzYWdlLicsXHJcbiAgICAgICAgICAgIDQwNFxyXG4gICAgICAgICk7XHJcbiAgICAgICAgb2JzZXJ2ZXIuZXJyb3IobmdjQ1NWUGFyc2VyRXJyb3IpO1xyXG4gICAgfVxyXG5cclxuICAgIGJhZENTVkRhdGFGb3JtYXRFcnJvckhhbmRsZXIob2JzZXJ2ZXI6IE9ic2VydmVyPGFueT4pIHtcclxuICAgICAgICBjb25zdCBuZ2NDU1ZQYXJzZXJFcnJvcjogTmd4Q1NWUGFyc2VyRXJyb3IgPSB0aGlzLmVycm9yQnVpbGRlcihcclxuICAgICAgICAgICAgJ0JBRF9DU1ZfREFUQV9GT1JNQVQnLFxyXG4gICAgICAgICAgICAnVW5hYmxlIHRvIHBhcnNlIENTViBGaWxlLicsXHJcbiAgICAgICAgICAgIDFcclxuICAgICAgICApO1xyXG4gICAgICAgIG9ic2VydmVyLmVycm9yKG5nY0NTVlBhcnNlckVycm9yKTtcclxuICAgIH1cclxuXHJcbiAgICBlcnJvckJ1aWxkZXIodHlwZTogc3RyaW5nLCBtZXNzYWdlOiBhbnksIGNvZGU6IGFueSk6IE5neENTVlBhcnNlckVycm9yIHtcclxuICAgICAgICBjb25zdCBuZ2NDU1ZQYXJzZXJFcnJvcjogTmd4Q1NWUGFyc2VyRXJyb3IgPSBuZXcgTmd4Q1NWUGFyc2VyRXJyb3IoKTtcclxuICAgICAgICBuZ2NDU1ZQYXJzZXJFcnJvci50eXBlID0gdHlwZTtcclxuICAgICAgICBuZ2NDU1ZQYXJzZXJFcnJvci5tZXNzYWdlID0gbWVzc2FnZTtcclxuICAgICAgICBuZ2NDU1ZQYXJzZXJFcnJvci5jb2RlID0gY29kZTtcclxuICAgICAgICByZXR1cm4gbmdjQ1NWUGFyc2VyRXJyb3I7XHJcbiAgICB9XHJcbn1cclxuIl19